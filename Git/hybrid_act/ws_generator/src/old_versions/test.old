#! /usr/bin/env python
import csv
import wx
#import wx.xrc
import numpy as np
import os
import main
import rospy
#from ws_generator.msg import WSArray
from std_msgs.msg import String

##############################################################################80
#class Texture:
#    """"""
#    def __init__(self, id, shape):
#        """Constructor"""
#        self.id = id
#        self.shape = shape

##############################################################################80
class Frame(wx.Frame):
    #----------------------------------------------------------------------
    def __init__(self):
        """"""
        #self.ws_ufm_pub = rospy.Publisher('/cursor_position/workspace/ufm', WSArray, queue_size = 0)
        #self.ws_ev_pub = rospy.Publisher('/cursor_position/workspace/ev', WSArray, queue_size = 0)
        #rospy.init_node('gui_ws')


        wx.Frame.__init__(self, parent = None, id = wx.ID_ANY, title = wx.EmptyString,size = wx.GetDisplaySize(), style = wx.SYSTEM_MENU)
        
        self.width, self.height = wx.GetDisplaySize()
        self.width_half = self.width/2.0

        self.first_rectangle_y = 0.1*self.height
        self.bottom_space = 0.035*self.height
        
        self.rectangle_size = 0.175*self.height
        self.rectangle_seperation = int((self.height-self.first_rectangle_y-self.bottom_space-3*self.rectangle_size)/3.0)
        
        #set up textbox and lines 
        self.textbox_width = self.width
        self.textbox_x = 0.04*self.width
        self.textbox_y = self.rectangle_size*0.35
        self.textbox_color1 = "WHITE"
        self.textbox_color2 = "WHITE"
        self.textbox_fontsize = int(42*(self.width/self.height))
        
        self.haptic_width = self.width - self.textbox_width
        
        self.background_color = "BLACK"
        
        # Add a panel so it looks correct on all platforms
        self.panel = wx.Panel(self, wx.ID_ANY)
        self.panel.Bind(wx.EVT_PAINT, self.OnPaint) 
        #set up screen
        self.layout()
        self.Centre()
        self.Show()

    def layout(self):#set up buttons and texts
        backButton = wx.Button(self.panel,wx.ID_ANY,'BACK')
        label = wx.StaticText(self.panel,wx.ID_ANY,label="Which one felt stronger?",pos=(0,.7*self.height))
        label.SetFont(wx.Font(self.textbox_fontsize,wx.ROMAN,wx.NORMAL,wx.BOLD))
        button_1 = wx.Button(self.panel,wx.ID_ANY, '1',pos=(0,self.height*.8),size=(self.width_half,.2*self.height))
        button_2 = wx.Button(self.panel,wx.ID_ANY, '2',pos=(self.width_half,self.height*.8),size=(self.width_half,.2*self.height))
        
        #set up font
        button_1.SetFont(wx.Font(self.textbox_fontsize,wx.ROMAN,wx.NORMAL,wx.BOLD))
        button_2.SetFont(wx.Font(self.textbox_fontsize,wx.ROMAN,wx.NORMAL,wx.BOLD))
        
        #define correct answer
        correct_selection=self.define_correct_selection()
        
        ##connect buttons to functions
        backButton.Bind(wx.EVT_BUTTON,self.onButton)
        #add arguments when connecting buttons to functions using lambda
        button_1.Bind(wx.EVT_BUTTON,lambda evt: self.option(evt,1,correct_selection))
        button_2.Bind(wx.EVT_BUTTON,lambda evt: self.option(evt,2,correct_selection))
        self.OnPaint(0)#draw again

    def onButton(self,event):#go home
        f = main.frameMain(None)
        self.Close()
        f.Show()
    
    def define_correct_selection(self):
        return(2)

    def option(self,event,selected,correct_selection):
        #print a message confirming whether option was correct or wrong
        if selected==correct_selection:
            message=wx.MessageDialog(self,"That is correct!","Answer",wx.OK)
            self.colorit()
        else:
            message=wx.MessageDialog(self,"Sorry, try again","Answer",wx.OK)
            self.colorit()
        message.ShowModal()
        #restart main page to try again
        self.textbox_color1 = "WHITE"
        self.textbox_color2 = "WHITE"
        self.layout()
    
    def colorit(self):
        #it paints the right answer
        correct_selection=self.define_correct_selection()
        if correct_selection==1:
            self.textbox_color1 = "BLUE"
        else:
            self.textbox_color2 = "BLUE"
        self.layout()
    #----------------------------------------------------------------------
    def widgetMaker(self, widget, objects):
        """"""
        for obj in objects:
            widget.Append(obj.shape, obj)
            widget.Bind(wx.EVT_COMBOBOX, self.onSelect)

    #----------------------------------------------------------------------
    def OnPaint(self, evt):
        """set up the device for painting"""
        dc = wx.PaintDC(self.panel)
        dc.BeginDrawing()
        brush = wx.Brush(self.background_color)
        dc.SetBackground(brush)
        dc.Clear()
        dc.SetFont(wx.Font(self.textbox_fontsize, wx.ROMAN, wx.FONTSTYLE_NORMAL, wx.NORMAL))

        """Rectangle 1"""
        rectangle_y = self.first_rectangle_y
        dc.SetBrush(wx.Brush(self.textbox_color1))
        dc.DrawRectangle(0, rectangle_y, self.textbox_width, self.rectangle_size)
        textbox = wx.Rect(self.textbox_x, rectangle_y+self.textbox_y)
        dc.DrawLabel("1)", textbox, alignment=1)

        """Rectangle 2"""
        rectangle_y = self.first_rectangle_y+(self.rectangle_size+self.rectangle_seperation)
        dc.SetBrush(wx.Brush(self.textbox_color2))
        dc.DrawRectangle(0, rectangle_y, self.textbox_width, self.rectangle_size)
        textbox = wx.Rect(self.textbox_x, rectangle_y+self.textbox_y)
        dc.DrawLabel("2)", textbox, alignment=1)
        dc.EndDrawing()
        del dc
    
    #----------------------------------------------------------------------
#    def onSelect(self, event):
#        """"""
#        print ("You selected: " + self.cb.GetStringSelection())
#        obj = self.cb.GetClientData(self.cb.GetSelection())
#        text = """
#        The object's attributes are:
#        %s  %s
#
#        """ % (obj.id, obj.shape)
#        print (text)
#        self.generate_workspace(self.cb.GetStringSelection())

#    def generate_workspace(self, texture):
#
#        ufm_intensity = []
#        ev_intensity = []
#
#        """Determine y workspace bounds"""
#        y_ws_ufm = []
#        y_ws_ev = []
#
#        rectangle_y = self.first_rectangle_y
#        y_ws_ev.append(rectangle_y)
#        y_ws_ev.append(rectangle_y+self.rectangle_size)
#
#        rectangle_y = rectangle_y + self.rectangle_size + self.rectangle_seperation
#        y_ws_ufm.append(rectangle_y)
#        y_ws_ufm.append(rectangle_y + self.rectangle_size)
#
#        rectangle_y = rectangle_y + self.rectangle_size + self.rectangle_seperation
#        y_ws_ev.append(rectangle_y)
#        y_ws_ev.append(rectangle_y + self.rectangle_size)
#        y_ws_ufm.append(rectangle_y)
#        y_ws_ufm.append(rectangle_y + self.rectangle_size)
#
#        """Determine x intensities correlating with texture"""
#        if texture == "Bump":
#
#            x_center = (self.haptic_width)/2
#            x_biasedcenter = x_center+self.textbox_width
#
#            x_haptic_switch = [x_biasedcenter-225,x_biasedcenter+225]
#            x_ufm_dropoff = [x_biasedcenter-400,x_biasedcenter+400]
#            x_ev_max = [x_biasedcenter-75,x_biasedcenter+75]
#
#            c1 = (x_haptic_switch[0]-x_biasedcenter)**2
#            c2 = (x_ufm_dropoff[0]-x_biasedcenter)**2
#            kufm = -c1/(c2-c1)
#            aufm = (1.0-kufm)/c2
#
#            c3 = (x_ev_max[0]-x_biasedcenter)**2
#            kev = -c1/(c3-c1)
#            aev = (1.0-kev)/c3
#
#            """Set haptic intensity = 0 over textbox"""
#            ufm_intensity = [0]*int(self.textbox_width)
#            ev_intensity = [0]*int(self.textbox_width)
#
#            for index in range(int(self.haptic_width)):
#                index = index + self.textbox_width
#
#                #print(x_ufm_dropoff, index)
#                if (index <= x_ufm_dropoff[0] or index >= x_ufm_dropoff[1]):
#                    ufm_intensity.append(1.0)
#                    ev_intensity.append(0.0)
#
#                else:
#                    ufm_int = aufm*(index-x_biasedcenter)**2+kufm
#                    ufm_intensity.append(max(0,min(1,ufm_int)))
#
#                    ev_int = aev*(index-x_biasedcenter)**2+kev
#                    ev_intensity.append(max(0,min(1,ev_int)))
#
#            #print (ufm_intensity)
#
#        elif texture == "Sinusoidal":
#            periods = 5
#
#            """Set haptic intensity = 0 over textbox"""
#            ufm_intensity = [0]*int(self.textbox_width)
#            ev_intensity = [0]*int(self.textbox_width)
#
#            for index in range(int(self.haptic_width)):
#                sinusoid = np.sin(index/self.haptic_width*periods*2*np.pi)
#                ufm_intensity.append(max(0,sinusoid))
#                ev_intensity.append(max(0,-sinusoid))
#
#        elif texture == "Triangular":
#            periods = 5
#            triangle_halfwidth = self.haptic_width/(2.0*2*periods)
#
#
#            """Set haptic intensity = 0 over textbox"""
#            ufm_intensity = [0]*int(self.textbox_width)
#            ev_intensity = [0]*int(self.textbox_width)
#            intensity = []
#            triangle_shape = []
#
#            for i in range(int(triangle_halfwidth)):
#                intensity = i/triangle_halfwidth
#                triangle_shape.append(intensity)
#                ufm_intensity.append(intensity)
#                ev_intensity.append(0.0)
#
#            for intensity in reversed(triangle_shape):
#                triangle_shape.append(intensity)
#                ufm_intensity.append(intensity)
#                ev_intensity.append(0.0)
#
#            for intensity in triangle_shape:
#                ev_intensity.append(intensity)
#                ufm_intensity.append(0.0)
#
#            if periods > 1:
#                for i in range(2,periods+1):
#                    for intensity in triangle_shape:
#                        ufm_intensity.append(intensity)
#                        ev_intensity.append(0.0)
#
#                    for intensity in triangle_shape:
#                        ufm_intensity.append(0.0)
#                        ev_intensity.append(intensity)
#
#        elif texture == "Square":
#            periods = 5
#
#            """Set haptic intensity = 0 over textbox"""
#            ufm_intensity = [0]*int(self.textbox_width)
#            ev_intensity = [0]*int(self.textbox_width)
#
#            for index in range(int(self.haptic_width)):
#                sinusoid = np.sin(index/self.haptic_width*periods*2*np.pi)
#                if (sinusoid > 0):
#                    ufm_intensity.append(1.0)
#                    ev_intensity.append(0.0)
#                else:
#                    ufm_intensity.append(0.0)
#                    ev_intensity.append(1.0)


# Run the program
if __name__ == "__main__":
    app = wx.App(False)
    frame = Frame()
    frame.Show()
    app.MainLoop()
